<25. JavaScript>

01.자바스크립트란 무엇인가?
- 자바스크립트는 스크립트 언어이자 인터프리터 언어로 자바랑 상관 없음
- 스크립트 언어를 해석해서 보여준게 웹브라우저
- 자바 스크립트는 동적으로 컨텐츠를 움직이고 바뀌게 해주는 역할을 함
- 현재는 웹브라우저에서만 사용하는 것은 아님
- 다양한 오픈소스 라이브러리가 존재함
-----------------------------------------------------------------
02. Various JavaScript Runtime
- 런타임 환경에는 다양한 것이 있는데 웹브라우저뿐만 아니라 node.js, electron 등도 있음
- 자바스크립트 문법의 표준화를 ecma에서 정의하고 있음
-----------------------------------------------------------------
03. 실습을 위한 준비
- 크롬과 node.js 에서 실습할 것
- 소스코드는 vscode에서 짤 것
- 실습환경 테스트 코드 25강 clip3.js
-----------------------------------------------------------------
04. Expression Statement
- 값을 만들어내는 간단한 코드를 표현식이라고 함
- 함수의 인자로써 사용할 수 있음
- 하나 혹은 여러개의 표현식이 모여 문장(Statement)을 이룸
- 모든 표현식은 문장이 될 수 있음
- 끝에는 ;를 붙임
- 콘솔에서 여러 문장을 사용 시 마지막 문장의 결과가 반환됨
-----------------------------------------------------------------
05. Keywords, Reserved, Words
- 키워드는 자바스크립트에서 특정한 목적을 위해 사용하는 단어, 키워드들은 모두 예약어임
- 대표적인 예시가 var(변수를 선언할 때 사용하는 언어)
- 예약어는 프로그램을 작성할 때 변수명, 함수명 등의 이름으로 사용할 수 없는 단어
- Future reserved keywords는 아직 사용하진 않지만 앞으로 사용할 것 같아서 미리 예약어 키워드로 지정해둔 것
-----------------------------------------------------------------
06. Identifier
- 식별자는 코드 내의 변수, 함수 또는 속성을 식별하는 문자열
- var name = 'Mark';하면 name이 식별자
- 식별자는 대소문자 구분
- 식별자에는 유니코드 문자, $, _, 숫자를 사용할 수 있지만 숫자로 시작은 불가
- 예약어는 사용할 수 없고, 공백문자 사용 불가
- 식별자가 한글도 가능하지만 보통 영문을 사용
- 변수 이름 짓는 것이 가장 어려움(역할에 맞게 잘 지정해야 하기 때문에)
-----------------------------------------------------------------
07. Comments
- 주석으로 실행되지 않는 코드
- 자바스크립트 주석은 //로 사용
- ctrl + /를 통해서 주석 처리 가능
-----------------------------------------------------------------
08. 변수와 상수
- 변수는 변할 수 있음(variable) 상수는 변할 수 없음(constant)
- 상수를 선언할 때에는 앞에 const를 붙임, 선언과 동시에 할당을 해주어야함
- let이라는 것을 앞에서 써서 변수를 선언
-----------------------------------------------------------------
09. 변수의 유효 범위
- const, let의 유효범위는 블록 스코프로 블록({})내에서만 사용
- var의 경우에는 유효범위가 함수 스코프임
- es5까지는 var로 변수를 선언했지만 es6에서는 const, let을 쓰도록 권장됨
- 함수 스코프는 function(){}의 영역으로 함수스코프는 함수 밖에서 호출 시 에러
- 함수 스코프의 경우 블록 스코프에 선언해두면 블록 밖에서도 사용 가능
-----------------------------------------------------------------
10. var와 호이스팅
- 호이스팅은 아래에 선언된 함수를 위에서 사용할 수 있도록 아래있는 선언을 위로 끌어올리는 것
- ex)
       hello();
       function hello(){
           console.log('hello');
       }
       하면 정상적으로 hello가 콘솔에서 출력됨
- 변수를 선언하고 호이스팅을 할 경우 선언만 위로 올라가기 때문에 아래에서 할당을 했다고 해도 undifined가 됨
- let을 사용할 경우 호이스팅 문제가 발생하지 않음
-----------------------------------------------------------------
11. 자료형
- 기본적으로 자바스크립트의 자료형은 동적 타이핑임 -> 안에 int냐 string이냐 이런 값들이 들어가면 자동으로 그걸로 설정이 되는 것
- 타입이 아예 없는 것은 아님.
- 기본타입 : boolean, null, undifined, number, string, symbol
- 객체타입도 존재 (const a = new number(1); 이런식으로 선언)
- typeof 변수를 하면 변수의 타입을 확인할 수 있음
- boolean 타입은 true, false
- null은 값이 없는 오브젝트라고 볼 수 있음
- undifined는 값이 undifined이고 타입도 undifined임
- null 과 undifined를 ==비교하면 같은 것으로 나옴, 따라서 보통은 ===으로 비교하여 타입까지 같은지 확인해야함
- number타입은 정수뿐만 아니라 실수도 포함
- NaN으로 할당할 경우 타입은 숫자인데 숫자가 아닌 값을 할당하면 NaN으로 표시됨
- string의 경우는 다른 언어들과는 다르게 1자리여도 char가 아닌 string 타입
- 템플릿 스트링이라는 선언 방식이 있는데 `` 사이에 값을 넣어서 선언해주며 a라는 변수가 선언되어있으면 const d = `${a} KIM'하면 a의 값 KIM으로 선언됨
- symbol은 es6에서 새로 생긴 타입으로 const a = Symbol(37); 이런 형태로 선언하며 고유한 것을 만들고 싶을 때 사용, 서로 같은 값을 갖는 다른 심볼 두개를 바교하면 ===으로 할경우 false가 나옴
-----------------------------------------------------------------
12, 13, 14, 15강 조건문
- 표현식이 참으로 평가될 대 실행되는 블럭
- 다른 언어들과 마찬가지로 if문을 사용
- 블록에 코드가 한줄이면 중괄호 생략 가능
- 표현식이 거짓으로 평가되는 경우 ( Falsy한 값 : false, 0, '', null, undifined, NaN)
- 표현식이 참으로 평가되는 경우 (Truethy한 값 : true, 37, 'Mark', {},[])
- 25강 example3.js
- if문이 거짓인 경우에 실행하는 블록은 else
- if문이 거짓인 경우 중에서 조건을 줄 경우 else if
- 25강 example5.js
- &&는 앞 뒤 모두가 참 인 경우 참
- ||는 앞 또는 뒤 둘중 하나가 참인 경우 참(앞이 참이면 뒤의 표현식을 실행하지 않음)
- 표현식의 경우 앞 표현식 부터 참인지 거짓인지 판별하고 넘어감
- 삼항연산자도 사용 가능
- 25강 example8.js
- switch-case문도 사용 가능
-----------------------------------------------------------------
16_1, 16_2강 반복문
- 동일한 코드를 여러번 반복할 때 사용
- 코드를 불필요하게 반복하는 것을 방지
- for문이나 while문, do-while문 사용
- 25강 반복문.js
- for(;;)로 쓰면 무한 반복
- do-while문은 실행하고 조건을 판별하고 반복or종료
- for in(모든 프로퍼티에서 사용 가능), for of(배열같은 iterable에서 사용)도 사용 가능
- 25강 forinof.js
-----------------------------------------------------------------
17, 18, 19강 함수
- 함수를 만들 때 function 함수명(){} 방식으로 선언
- 25강 func1.js
- const hello = function(){} 방식으로 선언 가능
- 이름 hello에 함수의 결과 값이 지정되는 것
- 선언적 function 과 익명의 방식으로 선언된 함수의 차이는 호이스팅이 되는가 안되는가의 차이(선언적 function은 호이스팅(변수가 끌어올려지는 것)이 되지만 익명의 방식은 호이스팅이 안됨)
- 생성자 함수로 함수를 만드는 방법은 const 함수명 = new Function(); 인데 잘 쓰이진 않음
- 25강 func2.js
- 생성자 함수로 함수를 만들 때 변수를 가져다가 쓰려면 글로벌 영역에 선언해줘야함, 다른 방식들은 지역의 변수들을 확인해서 가져가는 것
- es6에서는 arrow function라는 방식이 생겨남 () => {}
- 25강 func3.js
- arrow function 방식에서는 매개변수가 하나이면 ()를 생략할 수 있음(매개변수가 0개이거나 2개이상이면 무조건 ()를 붙여줘야함)
- arrow function 방식에서는 로직이 한줄일 경우에는 {}도 생략 가능
- 생성자 함수는 new 함수(); 방식을 사용하여 활용 가능
- 25강 func4.js
- 함수 안에서 함수를 만들어 리턴해줄 수 있음
- 25강 func5.js
- 함수를 인자로 하여 함수 호출 가능
-----------------------------------------------------------------
20_1, 20_2, 20_3, 20_4강 객체
- 객체는 object라고 부름
- 함수, 클래스를 통해서 객체를 만듬
- 생성자 함수는 객체를 만들어 내는 틀의 역할을 하는 함수
- 25강 object1.js
- 함수 내에 속성 값을 넣어줄 수 있음(프로퍼티)
- 25강 object2.js
- 객체도 new Object() 방식으로 선언 가능 이 방식도 권장되지 않음
- 25강 object2.js 의 c 부분
- 프로토타입으로 모든 객체들을 연결하여 표한 할 수 있는데 이걸 프로토타입 체인이라고 부름
- 25강 prototype_chain.js
- 프로토타입을 이용하여 객체 확장(프로토 타입을 통해서 상속을 할 수 있음)
- 25강 prototype_chain_2.js
- 프로토 타입 형식으로 체이닝 되어 활용할 수 있는 것
- 객체 리터럴을 사용하여 선언하는 방법은 const a = {}; 와 같이 사용
- 객체 리터럴에는 객체뿐만 아니라 함수를 넣을 수도 있음
- 25강 object_lit.js
- 표준 내장 객체라고 해서 이미 내장되어있는 객체도 있음
- 25강 object_in.js
-----------------------------------------------------------------
21, 22, 23, 24강 클래스
- 클래스는 es6에서 추가되었으며 객체를 만들 수 있는 새로운 방법임
- 클래스에서도 생성자(constructor) 를 통해서 생성될 때 바로 수행해 줄 것을 만들 수 있음
- 25강 class1.js
- 맴버 변수인 객체의 프로퍼티를 클래스에서는 더 쉽게 쓸 수 있음
- 25강 class2.js
- class 내에서 함수를 만들어서 사용 가능
- 25강 class3.js
- get, set을 이용하여 게터와 세터 설정 가능
- 게터 세터는 외부에서 접근하는 것이고 _변수명은 내부에서 사용하는 것을 표현할 때 사용하자
- 세터가 없으면 readonly 처럼 동작
- 25강 class4.js
- 클래스 내에서 static 변수와 함수를 선언해서 사용 가능, 접근할 때는 클래스명.스태틱변수명, new로 새로 만들어서 호출하면 에러남
- 25강 class5.js
- static name이라는 변수는 클래스명을 설정해줄 때 사용
- class를 상속할 때에는 extends를 사용
- 25강 class6.js
- 부모의 constructor에서 하는 동작을 똑같이 하려면 super키워드를 사용하면 됨
- 25강 class7.js
- static변수도 부모로부터 자식으로 상속됨
- 25강 class8.js
-----------------------------------------------------------------
25, 26, 27, 28강 Promise
- 비동기적인 상황에서 사용
- promise는 es6에서 추가되었음
- promise 객체는 생성자를 통해서 만들 수 있으며, executor 함수는 resolve와 reject를 인자로 갖는다.
- promise 객체는 만드는 순간 pending(대기) 상태임
- resolve 함수를 실행하면 fulfilled (이행) 상태로 변함
- reject함수를 실행하면 rejected (거부) 상태로 변함
- 25강 promise1.js
- 함수의 형태로서 promise를 사용할 수 있음
- 25강 promise2.js
- rejected 된 후에 실행하려면 p.then()뒤에 .catch()를 사용하면 된다.
- 25강 promise3.js
- resolve 나 reject의 ()사이에 값을 넣어서 넘겨줄 수 있음
- 25강 promise4.js
- 실패할 때에는 보통 에러의 원인을 넣어서도 보냄
- then이나 catch 후에 최종으로 실행할 일이 있다면 finally()를 넣어서 수행해주면 됨
- 보통 비동기 작업을 할 때, callback 함수를 인자로 넣어 로직이 끝나면 callback 함수를 호출
- 25강 promise5.js
- then함수에서 다시 프로미스 객체를 리턴하는 방식을 통해 체이닝하면, 비동기 작업을 순차적으로 표현할 수 있음
- 25강 promise6.js
- Promise.resolve() 함수를 사용하면 이게 promise인지 아닌지 알 수 있음
-----------------------------------------------------------------